
typedef struct Node {
    int data;
    struct Node* next;
    struct Node* prev;
}Node;

typedef struct DLL {
  char* name;
  int sz;
  int curr_sz;
  Node** list;
} DDL;
typedef struct _Variable
{
  char *name;
  int type, size, localAddress, arrLen, isTobeCleaned;
} Variable;
typedef struct _Stack
{
  Variable *stck[STACK_SIZE];
  int topIndex;
} Stack;

typedef struct
{
  int *pageTable[NUM_VARIABLES];
  int localAddress, maxMemIndex;
  int actualAddressToLocalAdress[MEM_SIZE / 4];
  Variable variableList[NUM_VARIABLES];
  Stack variableStack;
  pthread_mutex_t lock;
  pthread_attr_t attr;
  pthread_t ptid;
} Data;


// Important Data Structures
extern int *memory_;
extern Data *data_;

int createArr(char *name, int type, int arrLen)
{
  printf("Creating Array of name: %s and type %s and length %d\n", name, getTypeString(type), arrLen);
  if (data_->localAddress / 4 >= NUM_VARIABLES)
  {
    fprintf(stderr, "Variable count limit reached. Exitting.\n");
    exit(1);
  }
  Variable *var = CreateVariable(name, type, data_->localAddress, arrLen);
  data_->variableList[data_->localAddress / 4] = *var;
  no_gc += var->size;
  gc += var->size;
  int len = var->size;
  pthread_mutex_lock(&data_->lock);
  for (int i = 0; i < MEM_SIZE / 4; i++)
  {
    int flag = 1;
    for (int j = 0; j < len; j++)
    {
      if (j + i < MEM_SIZE / 4)
      {
        if (!(data_->actualAddressToLocalAdress[i + j] == -1))
        {
          flag = 0;
          break;
        }
      }
      else
        break;
    }
    if (flag == 1)
    {
      for (int j = 0; j < len; j++)
      {
        if (j + i < MEM_SIZE / 4)
        {
          data_->maxMemIndex = max(data_->maxMemIndex, i + j);
          data_->actualAddressToLocalAdress[j + i] = data_->localAddress;
        }
      }
      data_->pageTable[data_->localAddress / 4] = memory_ + i;
      break;
    }
  }
  pthread_mutex_unlock(&data_->lock);
  int temp = data_->localAddress;
  data_->localAddress += 4;
  push(&data_->variableStack, &data_->variableList[temp / 4]);
  return temp;
}


// int getValueVarInt(int localAddr)
// {
//   if (!typeCheck(localAddr, INT))
//   {
//     fprintf(stderr, "ERROR: Type Mismatch\n");
//     exit(1);
//   }
//   int *physicalAddress = data_->pageTable[localAddr / 4];
//   return *physicalAddress;
// }
// char getValueVarChar(int localAddr)
// {
//   if (!typeCheck(localAddr, CHAR))
//   {
//     fprintf(stderr, "ERROR: Type Mismatch\n");
//     exit(1);
//   }
//   int *physicalAddress = data_->pageTable[localAddr / 4];
//   return *physicalAddress;
// }
// bool getValueVarBool(int localAddr)
// {
//   if (!typeCheck(localAddr, BOOLEAN))
//   {
//     fprintf(stderr, "ERROR: Type Mismatch\n");
//     exit(1);
//   }
//   int *physicalAddress = data_->pageTable[localAddr / 4];
//   return *physicalAddress;
// }
// mediumInt getValueVarMedInt(int localAddr)
// {
//   if (!typeCheck(localAddr, MEDIUM_INT))
//   {
//     fprintf(stderr, "ERROR: Type Mismatch\n");
//     exit(1);
//   }
//   int *physicalAddress = data_->pageTable[localAddr / 4];
//   return CreateMediumInt(*physicalAddress);
// }
// int createArr(char *name, int type, int arrLen)
// {
//   printf("Creating Array of name: %s and type %s and length %d\n", name, getTypeString(type), arrLen);
//   if (data_->localAddress / 4 >= NUM_VARIABLES)
//   {
//     fprintf(stderr, "Variable count limit reached. Exitting.\n");
//     exit(1);
//   }
//   Variable *var = CreateVariable(name, type, data_->localAddress, arrLen);
//   data_->variableList[data_->localAddress / 4] = *var;
//   no_gc += var->size;
//   gc += var->size;
//   int len = var->size;
//   pthread_mutex_lock(&data_->lock);
//   for (int i = 0; i < MEM_SIZE / 4; i++)
//   {
//     int flag = 1;
//     for (int j = 0; j < len; j++)
//     {
//       if (j + i < MEM_SIZE / 4)
//       {
//         if (!(data_->actualAddressToLocalAdress[i + j] == -1))
//         {
//           flag = 0;
//           break;
//         }
//       }
//       else
//         break;
//     }
//     if (flag == 1)
//     {
//       for (int j = 0; j < len; j++)
//       {
//         if (j + i < MEM_SIZE / 4)
//         {
//           data_->maxMemIndex = max(data_->maxMemIndex, i + j);
//           data_->actualAddressToLocalAdress[j + i] = data_->localAddress;
//         }
//       }
//       data_->pageTable[data_->localAddress / 4] = memory_ + i;
//       break;
//     }
//   }
//   pthread_mutex_unlock(&data_->lock);
//   int temp = data_->localAddress;
//   data_->localAddress += 4;
//   push(&data_->variableStack, &data_->variableList[temp / 4]);
//   return temp;
// }
// void assignArrInt(int localAddr, int index, int value)
// {
//   if (!typeCheck(localAddr, INT))
//   {
//     fprintf(stderr, "ERROR: Type Mismatch\n");
//     exit(1);
//   }
//   pthread_mutex_lock(&data_->lock);
//   int *physicalAddress = data_->pageTable[localAddr / 4];
//   if (index < 0 || index >= data_->variableList[localAddr / 4].arrLen)
//   {
//     fprintf(stderr, "Assigning value at Invalid Index.\n");
//     exit(1);
//   }
//   physicalAddress[index] = value;
//   pthread_mutex_unlock(&data_->lock);
// }
// void assignArrChar(int localAddr, int index, char value)
// {
//   if (!typeCheck(localAddr, CHAR))
//   {
//     fprintf(stderr, "ERROR: Type Mismatch\n");
//     exit(1);
//   }
//   pthread_mutex_lock(&data_->lock);
//   char *physicalAddress = (char *)data_->pageTable[localAddr / 4];
//   if (index < 0 || index >= data_->variableList[localAddr / 4].arrLen)
//   {
//     fprintf(stderr, "Assigning value at Invalid Index.\n");
//     exit(1);
//   }
//   physicalAddress[index] = value;
//   pthread_mutex_unlock(&data_->lock);
// }
// void assignArrBool(int localAddr, int index, bool value)
// {
//   if (!typeCheck(localAddr, BOOLEAN))
//   {
//     fprintf(stderr, "ERROR: Type Mismatch\n");
//     exit(1);
//   }
//   pthread_mutex_lock(&data_->lock);
//   bool *physicalAddress = (bool *)data_->pageTable[localAddr / 4];
//   if (index < 0 || index >= data_->variableList[localAddr / 4].arrLen)
//   {
//     fprintf(stderr, "Assigning value at Invalid Index.\n");
//     exit(1);
//   }
//   physicalAddress[index] = value;
//   pthread_mutex_unlock(&data_->lock);
// }
// void assignArrMedium(int localAddr, int index, mediumInt value)
// {
//   if (!typeCheck(localAddr, MEDIUM_INT))
//   {
//     fprintf(stderr, "ERROR: Type Mismatch\n");
//     exit(1);
//   }
//   pthread_mutex_lock(&data_->lock);
//   mediumInt *physicalAddress = (mediumInt *)data_->pageTable[localAddr / 4];
//   if (index < 0 || index >= data_->variableList[localAddr / 4].arrLen)
//   {
//     fprintf(stderr, "Assigning value at Invalid Index.\n");
//     exit(1);
//   }
//   physicalAddress[index] = value;
//   pthread_mutex_unlock(&data_->lock);
// }
// int getValueArrInt(int localAddr, int index)
// {
//   if (!typeCheck(localAddr, INT))
//   {
//     fprintf(stderr, "ERROR: Type Mismatch\n");
//     exit(1);
//   }
//   if (index < 0 || index >= data_->variableList[localAddr / 4].arrLen)
//   {
//     fprintf(stderr, "Accessing invalid index\n");
//     exit(1);
//   }
//   int *physicalAddress = data_->pageTable[localAddr / 4];
//   int val = physicalAddress[index];
//   return val;
// }
// char getValueArrChar(int localAddr, int index)
// {
//   if (!typeCheck(localAddr, CHAR))
//   {
//     fprintf(stderr, "ERROR: Type Mismatch\n");
//     exit(1);
//   }
//   if (index < 0 || index >= data_->variableList[localAddr / 4].arrLen)
//   {
//     fprintf(stderr, "Accessing invalid index\n");
//     exit(1);
//   }
//   char *physicalAddress = (char *)data_->pageTable[localAddr / 4];
//   char val = physicalAddress[index];
//   return val;
// }
// bool getValueArrBool(int localAddr, int index)
// {
//   if (!typeCheck(localAddr, BOOLEAN))
//   {
//     fprintf(stderr, "ERROR: Type Mismatch\n");
//     exit(1);
//   }
//   if (index < 0 || index >= data_->variableList[localAddr / 4].arrLen)
//   {
//     fprintf(stderr, "Accessing invalid index\n");
//     exit(1);
//   }
//   bool *physicalAddress = (bool *)data_->pageTable[localAddr / 4];
//   return physicalAddress[index];
// }
// mediumInt getValueArrMedInt(int localAddr, int index)
// {
//   if (!typeCheck(localAddr, MEDIUM_INT))
//   {
//     fprintf(stderr, "ERROR: Type Mismatch\n");
//     exit(1);
//   }
//   if (index < 0 || index >= data_->variableList[localAddr / 4].arrLen)
//   {
//     fprintf(stderr, "Accessing invalid index\n");
//     exit(1);
//   }
//   mediumInt *physicalAddress = (mediumInt *)data_->pageTable[localAddr / 4];
//   return physicalAddress[index];
// }
// void addToArr(int localAddress, int index, int value)
// {
//   if (!typeCheck(localAddress, INT))
//   {
//     fprintf(stderr, "ERROR: Type Mismatch\n");
//     exit(1);
//   }
//   if (index < 0 || index >= data_->variableList[localAddress / 4].arrLen)
//   {
//     fprintf(stderr, "Accessing invalid index\n");
//     exit(1);
//   }
//   int *physicalAddress = data_->pageTable[localAddress / 4];
//   physicalAddress[index] = physicalAddress[index] + value;
// }
// void multToArr(int localAddress, int index, int value)
// {
//   if (!typeCheck(localAddress, INT))
//   {
//     fprintf(stderr, "ERROR: Type Mismatch\n");
//     exit(1);
//   }
//   if (index < 0 || index >= data_->variableList[localAddress / 4].arrLen)
//   {
//     fprintf(stderr, "Accessing invalid index\n");
//     exit(1);
//   }
//   int *physicalAddress = data_->pageTable[localAddress / 4];
//   physicalAddress[index] = physicalAddress[index] * value;
// }
// C program for merge sort on doubly linked list
// #include<stdio.h>
// #include<stdlib.h>
// struct Node
// {
// 	int data;
// 	struct Node *next, *prev;
// };

// struct Node *split(struct Node *head);

// // Function to merge two linked lists
// struct Node *merge(struct Node *first, struct Node *second)
// {
// 	// If first linked list is empty
// 	if (!first)
// 		return second;

// 	// If second linked list is empty
// 	if (!second)
// 		return first;

// 	// Pick the smaller value
// 	if (first->data < second->data)
// 	{
// 		first->next = merge(first->next,second);
// 		first->next->prev = first;
// 		first->prev = NULL;
// 		return first;
// 	}
// 	else
// 	{
// 		second->next = merge(first,second->next);
// 		second->next->prev = second;
// 		second->prev = NULL;
// 		return second;
// 	}
// }

// // Function to do merge sort
// struct Node *mergeSort(struct Node *head)
// {
// 	if (!head || !head->next)
// 		return head;
// 	struct Node *second = split(head);

// 	// Recur for left and right halves
// 	head = mergeSort(head);
// 	second = mergeSort(second);

// 	// Merge the two sorted halves
// 	return merge(head,second);
// }

// // A utility function to insert a new node at the
// // beginning of doubly linked list
// void insert(struct Node **head, int data)
// {
// 	struct Node *temp = (struct Node *)malloc(sizeof(struct Node));
// 	temp->data = data;
// 	temp->next = temp->prev = NULL;
// 	if (!(*head))
// 		(*head) = temp;
// 	else
// 	{
// 		temp->next = *head;
// 		(*head)->prev = temp;
// 		(*head) = temp;
// 	}
// }

// // A utility function to print a doubly linked list in
// // both forward and backward directions
// void print(struct Node *head)
// {
// 	struct Node *temp = head;
// 	printf("Forward Traversal using next pointer\n");
// 	while (head)
// 	{
// 		printf("%d ",head->data);
// 		temp = head;
// 		head = head->next;
// 	}
// 	printf("\nBackward Traversal using prev pointer\n");
// 	while (temp)
// 	{
// 		printf("%d ", temp->data);
// 		temp = temp->prev;
// 	}
// }

// // Utility function to swap two integers
// void swap(int *A, int *B)
// {
// 	int temp = *A;
// 	*A = *B;
// 	*B = temp;
// }

// // Split a doubly linked list (DLL) into 2 DLLs of
// // half sizes
// struct Node *split(struct Node *head)
// {
// 	struct Node *fast = head,*slow = head;
// 	while (fast->next && fast->next->next)
// 	{
// 		fast = fast->next->next;
// 		slow = slow->next;
// 	}
// 	struct Node *temp = slow->next;
// 	slow->next = NULL;
// 	return temp;
// }

// // Driver program
// int main(void)
// {
// 	struct Node *head = NULL;
// 	insert(&head,5);
// 	insert(&head,20);
// 	insert(&head,4);
// 	insert(&head,3);
// 	insert(&head,30);
// 	insert(&head,10);
// 	head = mergeSort(head);
// 	printf("\n\nLinked List after sorting\n");
// 	print(head);
// 	return 0;
// }