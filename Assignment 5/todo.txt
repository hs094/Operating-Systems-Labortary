1. seperate the code into three dif files
● Create three programs (in C or CPP), one for the main thread, 
one for the guest, and one for the cleaning staff.
 Also create a Makefile that will compile all programs.
● Include a short report DESIGNDOC, as a pdf file. 
it should describe what is your design for the three threads, 
what data structures did you use and what semaphores did you use on them.

Make the duration right and plan of evicition and handle that and make the time of cleaning proportional to the time needed.
Make DESIGNDOC quick.

This code implements a multi-threaded program for managing a hotel, where guests can check-in and occupy rooms, and cleaning staff clean the rooms once they are vacant. The guests wait until all the cleaning staff finish cleaning the rooms, and then start execution. Similarly, the cleaning staff wait until all the guests leave the hotel rooms and then start cleaning the rooms.

The program uses the following data structures:

A vector of Room objects named "hotel", where each room is represented by a Room object containing information such as priority, occupancy status, the previous guest who occupied the room, and the last time the room was cleaned.
Integers X, Y, and N representing the number of cleaning staff, guests, and rooms in the hotel, respectively.
A vector of integers named "guests_priority" that stores the priority of each guest thread.
A vector of vectors of integers named "cleaner_pre" representing the set of rooms that each cleaning staff needs to clean.
A vector of semaphores named "cleaning_semaphores", where each semaphore represents a room that needs to be cleaned.
A vector of booleans named "cleaning_in_progress" representing whether the cleaning of a room is in progress by a cleaning staff.
The program uses three types of threads: guest threads, cleaning threads, and the main thread. The guest threads randomly occupy a room and wait for a random amount of time before releasing the room. The cleaning threads wait until a set of rooms need to be cleaned, clean them, and then notify all the waiting guest threads. The main thread creates and joins all the guest and cleaning threads.

Overall, the program implements a simple synchronization mechanism between the guest and cleaning threads using mutexes and condition variables. However, the implementation can be improved in several ways:

Deadlock: There is a potential deadlock when all the cleaning staff are waiting for all the guests to leave the hotel rooms, and all the guests are waiting for all the cleaning staff to finish cleaning the rooms. To avoid this deadlock, the program can allow the guests to occupy and release the rooms even when the cleaning is in progress. This can be achieved by modifying the "is_cleaning_needed" function to return true only when the room is occupied by more than two guests and is not currently being cleaned. The program can also modify the "release_room" function to release the room immediately if it is not occupied by more than two guests and is not being cleaned.

Room allocation: The current implementation uses a simple algorithm to allocate rooms to guests based on their priorities. However, this algorithm may not be optimal and can lead to guests waiting for a long time to occupy a room. The program can use a more sophisticated algorithm to allocate rooms to guests, such as using a queue or a reservation system.

Cleaning schedule: The current implementation assigns a fixed set of rooms to each cleaning staff. However, this schedule may not be optimal and can lead to some cleaning staff having more work than others. The program can implement a dynamic cleaning schedule that assigns the cleaning staff to rooms based on the occupancy status and the last time the room was cleaned.

Code optimization: The current implementation has some performance issues, such as using a for loop to iterate over all the rooms to check whether cleaning is needed. This operation can be optimized by using a data structure, such as a priority queue, that stores only the rooms that need cleaning. The program can also use thread pools instead of creating new threads for each guest and cleaning staff.

In conclusion, the current implementation provides a simple solution to the hotel management problem, but it can be improved in several ways to make it more efficient and scalable.